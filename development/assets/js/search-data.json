{"0": {
    "doc": "API Reference",
    "title": "API Reference",
    "content": "# API Reference Complete reference documentation for all public methods and types in the AS5047U driver. ## Source Code - **Main Header**: [`inc/as5047u.hpp`](../inc/as5047u.hpp) - **SPI Interface**: [`inc/as5047u_spi_interface.hpp`](../inc/as5047u_spi_interface.hpp) - **Implementation**: [`src/as5047u.cpp`](../src/as5047u.cpp) - **Registers**: [`inc/as5047u_registers.hpp`](../inc/as5047u_registers.hpp) ## Core Class ### `AS5047U` Main driver class for interfacing with the AS5047U magnetic encoder. **Template Parameter**: `SpiType` - Type implementing `as5047u::SpiInterface` **Location**: [`inc/as5047u.hpp#L78`](../inc/as5047u.hpp#L78) **Constructor:** ```cpp explicit AS5047U(SpiType& bus, FrameFormat format = AS5047U_CFG::DEFAULT_FRAME_FORMAT) noexcept; ``` **Location**: [`inc/as5047u.hpp#L91`](../inc/as5047u.hpp#L91) ## Methods ### Frame Format | Method | Signature | Location |--------|-----------|----------| `SetFrameFormat()` | `void SetFrameFormat(FrameFormat format) noexcept` | [`src/as5047u.cpp#L16`](../src/as5047u.cpp#L16) | ### Angle Reading | Method | Signature | Location |--------|-----------|----------| `GetAngle()` | `uint16_t GetAngle(uint8_t retries = AS5047U_CFG::CRC_RETRIES) const` | [`src/as5047u.cpp#L33`](../src/as5047u.cpp#L33) | `GetRawAngle()` | `uint16_t GetRawAngle(uint8_t retries = AS5047U_CFG::CRC_RETRIES) const` | [`src/as5047u.cpp#L48`](../src/as5047u.cpp#L48) | ### Velocity Reading | Method | Signature | Location |--------|-----------|----------| `GetVelocity()` | `int16_t GetVelocity(uint8_t retries = AS5047U_CFG::CRC_RETRIES) const` | [`src/as5047u.cpp#L63`](../src/as5047u.cpp#L63) | `GetVelocityDegPerSec()` | `float GetVelocityDegPerSec(uint8_t retries = AS5047U_CFG::CRC_RETRIES) const` | [`src/as5047u.cpp#L79`](../src/as5047u.cpp#L79) | `GetVelocityRadPerSec()` | `float GetVelocityRadPerSec(uint8_t retries = AS5047U_CFG::CRC_RETRIES) const` | [`src/as5047u.cpp#L84`](../src/as5047u.cpp#L84) | `GetVelocityRPM()` | `float GetVelocityRPM(uint8_t retries = AS5047U_CFG::CRC_RETRIES) const` | [`src/as5047u.cpp#L89`](../src/as5047u.cpp#L89) | ### Diagnostics | Method | Signature | Location |--------|-----------|----------| `GetAGC()` | `uint8_t GetAGC(uint8_t retries = AS5047U_CFG::CRC_RETRIES) const` | [`src/as5047u.cpp#L94`](../src/as5047u.cpp#L94) | `GetMagnitude()` | `uint16_t GetMagnitude(uint8_t retries = AS5047U_CFG::CRC_RETRIES) const` | [`src/as5047u.cpp#L109`](../src/as5047u.cpp#L109) | `GetErrorFlags()` | `uint16_t GetErrorFlags(uint8_t retries = AS5047U_CFG::CRC_RETRIES) const` | [`src/as5047u.cpp#L124`](../src/as5047u.cpp#L124) | `GetStickyErrorFlags()` | `AS5047U_Error GetStickyErrorFlags() const` | [`inc/as5047u.hpp#L384`](../inc/as5047u.hpp#L384) | `DumpStatus()` | `void DumpStatus() const` | [`src/as5047u.cpp#L597`](../src/as5047u.cpp#L597) | `GetDiagnostics()` | `AS5047U_REG::DIA GetDiagnostics() const` | [`src/as5047u.cpp#L393`](../src/as5047u.cpp#L393) | ### Configuration | Method | Signature | Location |--------|-----------|----------| `GetZeroPosition()` | `uint16_t GetZeroPosition(uint8_t retries = AS5047U_CFG::CRC_RETRIES) const` | [`src/as5047u.cpp#L135`](../src/as5047u.cpp#L135) | `SetZeroPosition()` | `bool SetZeroPosition(uint16_t angle_lsb, uint8_t retries = AS5047U_CFG::CRC_RETRIES)` | [`src/as5047u.cpp#L162`](../src/as5047u.cpp#L162) | `SetDirection()` | `bool SetDirection(bool clockwise, uint8_t retries = AS5047U_CFG::CRC_RETRIES)` | [`inc/as5047u.hpp#L214`](../inc/as5047u.hpp#L214) | `SetABIResolution()` | `bool SetABIResolution(uint8_t resolution_bits, uint8_t retries = AS5047U_CFG::CRC_RETRIES)` | [`src/as5047u.cpp#L171`](../src/as5047u.cpp#L171) | `SetUVWPolePairs()` | `bool SetUVWPolePairs(uint8_t pairs, uint8_t retries = AS5047U_CFG::CRC_RETRIES)` | [`src/as5047u.cpp#L179`](../src/as5047u.cpp#L179) | `SetIndexPulseLength()` | `bool SetIndexPulseLength(uint8_t lsb_len, uint8_t retries = AS5047U_CFG::CRC_RETRIES)` | [`src/as5047u.cpp#L187`](../src/as5047u.cpp#L187) | `ConfigureInterface()` | `bool ConfigureInterface(bool abi, bool uvw, bool pwm, uint8_t retries = AS5047U_CFG::CRC_RETRIES)` | [`src/as5047u.cpp#L205`](../src/as5047u.cpp#L205) | `SetDynamicAngleCompensation()` | `bool SetDynamicAngleCompensation(bool enable, uint8_t retries = AS5047U_CFG::CRC_RETRIES)` | [`src/as5047u.cpp#L225`](../src/as5047u.cpp#L225) | `SetAdaptiveFilter()` | `bool SetAdaptiveFilter(bool enable, uint8_t retries = AS5047U_CFG::CRC_RETRIES)` | [`src/as5047u.cpp#L232`](../src/as5047u.cpp#L232) | `SetFilterParameters()` | `bool SetFilterParameters(uint8_t k_min, uint8_t k_max, uint8_t retries = AS5047U_CFG::CRC_RETRIES)` | [`src/as5047u.cpp#L239`](../src/as5047u.cpp#L239) | `Set150CTemperatureMode()` | `bool Set150CTemperatureMode(bool enable, uint8_t retries = AS5047U_CFG::CRC_RETRIES)` | [`src/as5047u.cpp#L250`](../src/as5047u.cpp#L250) | `SetHysteresis()` | `bool SetHysteresis(AS5047U_REG::SETTINGS3::Hysteresis hysteresis, uint8_t retries = AS5047U_CFG::CRC_RETRIES)` | [`src/as5047u.cpp#L315`](../src/as5047u.cpp#L315) | `GetHysteresis()` | `AS5047U_REG::SETTINGS3::Hysteresis GetHysteresis() const` | [`src/as5047u.cpp#L322`](../src/as5047u.cpp#L322) | `SetAngleOutputSource()` | `bool SetAngleOutputSource(AS5047U_REG::SETTINGS2::AngleOutputSource source, uint8_t retries = AS5047U_CFG::CRC_RETRIES)` | [`src/as5047u.cpp#L333`](../src/as5047u.cpp#L333) | `GetAngleOutputSource()` | `AS5047U_REG::SETTINGS2::AngleOutputSource GetAngleOutputSource() const` | [`src/as5047u.cpp#L340`](../src/as5047u.cpp#L340) | ### OTP Programming | Method | Signature | Location |--------|-----------|----------| `ProgramOTP()` | `bool ProgramOTP()` | [`src/as5047u.cpp#L257`](../src/as5047u.cpp#L257) | ### Utility | Method | Signature | Location |--------|-----------|----------| `SetPad()` | `void SetPad(uint8_t pad) noexcept` | [`src/as5047u.cpp#L302`](../src/as5047u.cpp#L302) | `ComputeCRC8()` | `static constexpr uint8_t ComputeCRC8(uint16_t data16)` | [`inc/as5047u.hpp#L96`](../inc/as5047u.hpp#L96) | `ReadReg()` | `template RegT ReadReg() const` | [`inc/as5047u.hpp#L360`](../inc/as5047u.hpp#L360) | `WriteReg()` | `template bool WriteReg(const RegT& reg, uint8_t retries = AS5047U_CFG::CRC_RETRIES)` | [`inc/as5047u.hpp#L376`](../inc/as5047u.hpp#L376) | ## Types ### Enumerations | Type | Values | Location |------|--------|----------| `FrameFormat` | `SPI_16`, `SPI_24`, `SPI_32` | [`inc/as5047u_types.hpp#L15`](../inc/as5047u_types.hpp#L15) | `AS5047U_Error` | `None`, `AgcWarning`, `MagHalf`, `CrcError`, `FramingError`, `CommandError`, `WatchdogError`, `OffCompError`, `CordicOverflow` | [`inc/as5047u.hpp#L32`](../inc/as5047u.hpp#L32) | ### Structures | Type | Description | Location |------|-------------|----------| `AS5047U_REG::DIA` | Diagnostic register structure | [`inc/as5047u_registers.hpp`](../inc/as5047u_registers.hpp) | `AS5047U_REG::SETTINGS2::AngleOutputSource` | Angle output source enumeration | [`inc/as5047u_registers.hpp`](../inc/as5047u_registers.hpp) | `AS5047U_REG::SETTINGS3::Hysteresis` | Hysteresis enumeration | [`inc/as5047u_registers.hpp`](../inc/as5047u_registers.hpp) | --- **Navigation** ‚¨ÖÔ∏è [Configuration](/hf-as5047u-driver/development/docs/configuration.html) | [Next: Examples ‚û°Ô∏è](/hf-as5047u-driver/development/docs/examples.html) | [Back to Index](/hf-as5047u-driver/development/docs/) ",
    "url": "/hf-as5047u-driver/development/docs/api_reference.html",
    
    "relUrl": "/docs/api_reference.html"
  },"1": {
    "doc": "Configuration",
    "title": "Configuration",
    "content": "# Configuration This guide covers all configuration options available for the AS5047U driver. ## Compile-Time Configuration ### Kconfig Options If your project uses Kconfig (e.g., ESP-IDF), the following options are available: ``` AS5047U Configuration AS5047U_FRAME_FORMAT (16/24/32-bit) AS5047U_CRC_RETRIES (default: 0) ``` ### Configuration Header You can also configure the driver by editing `inc/AS5047U_config.hpp`: ```cpp namespace AS5047U_CFG { // Default SPI frame format inline constexpr FrameFormat DEFAULT_FRAME_FORMAT = FrameFormat::SPI_24; // Number of CRC retries (0 = no retry) inline constexpr uint8_t CRC_RETRIES = 3; } ``` ## Runtime Configuration ### SPI Frame Format The driver supports three SPI frame formats: ```cpp // 16-bit frames (no CRC, highest throughput) as5047u::AS5047U encoder(spi, FrameFormat::SPI_16); // 24-bit frames (includes 8-bit CRC, recommended) as5047u::AS5047U encoder(spi, FrameFormat::SPI_24); // 32-bit frames (includes 8-bit CRC + 8-bit pad for daisy-chain) as5047u::AS5047U encoder(spi, FrameFormat::SPI_32); ``` **Recommendation**: Use `SPI_24` for most applications - it provides CRC protection with good throughput. ### Change Frame Format at Runtime ```cpp encoder.SetFrameFormat(FrameFormat::SPI_24); ``` ## Sensor Configuration ### Zero Position Set the zero reference position (soft offset): ```cpp // Set zero position to current angle uint16_t current_angle = encoder.GetAngle(); encoder.SetZeroPosition(current_angle); // Or set a specific value (0-16383) encoder.SetZeroPosition(8192); // 180 degrees ``` ### Rotation Direction ```cpp // Clockwise rotation yields increasing angle (default) encoder.SetDirection(true); // Counter-clockwise rotation yields increasing angle encoder.SetDirection(false); ``` ### Dynamic Angle Error Compensation (DAEC) DAEC provides low-latency angle correction for high-speed applications: ```cpp // Enable DAEC (recommended for high-speed applications) encoder.SetDynamicAngleCompensation(true); // Disable DAEC (use raw angle) encoder.SetDynamicAngleCompensation(false); ``` ### Adaptive Filter (DFS‚Ñ¢) The Dynamic Filter System adaptively filters noise: ```cpp // Enable adaptive filter encoder.SetAdaptiveFilter(true); // Set filter parameters (K_min, K_max) // K_min: minimum filter strength (0-15) // K_max: maximum filter strength (0-15) encoder.SetFilterParameters(2, 3); ``` ### Angle Output Source Select which angle is used for outputs (ABI, UVW, PWM): ```cpp // Use compensated angle (with DAEC) encoder.SetAngleOutputSource(AS5047U_REG::SETTINGS2::AngleOutputSource::Compensated); // Use raw angle (without DAEC) encoder.SetAngleOutputSource(AS5047U_REG::SETTINGS2::AngleOutputSource::Raw); ``` ## Output Configuration ### ABI (Incremental Encoder) Output Configure incremental encoder outputs (A, B, I): ```cpp // Set resolution (10-14 bits) encoder.SetABIResolution(12); // 12-bit = 4096 PPR // Set index pulse length (1 or 3 LSB periods) encoder.SetIndexPulseLength(1); // Enable ABI output encoder.ConfigureInterface(true, false, false); // ABI only ``` ### UVW (Commutation) Output Configure 3-phase commutation outputs: ```cpp // Set number of pole pairs (1-7) encoder.SetUVWPolePairs(5); // 5 pole pairs // Enable UVW output encoder.ConfigureInterface(false, true, false); // UVW only ``` ### PWM Output Configure PWM-encoded angle output: ```cpp // Enable PWM output // PWM appears on W pin if ABI enabled, or I pin if UVW enabled encoder.ConfigureInterface(true, false, true); // ABI + PWM ``` ### Combined Outputs ```cpp // Enable both ABI and UVW (PWM not available in this mode) encoder.ConfigureInterface(true, true, false); // Enable ABI with PWM on W pin encoder.ConfigureInterface(true, false, true); ``` ## Advanced Configuration ### Hysteresis Set incremental output hysteresis to reduce jitter: ```cpp // Set hysteresis level encoder.SetHysteresis(AS5047U_REG::SETTINGS3::Hysteresis::LSB_1); ``` ### High-Temperature Mode Enable 150¬∞C operation mode: ```cpp encoder.Set150CTemperatureMode(true); ``` ### OTP Programming Program current settings into OTP (One-Time Programmable) memory for permanent configuration: ```cpp // Configure all settings first encoder.SetZeroPosition(0); encoder.SetDirection(true); encoder.SetABIResolution(12); // ... other settings // Program to OTP (one-time operation, cannot be undone) bool success = encoder.ProgramOTP(); if (success) { // Settings are now permanent } ``` **Warning**: OTP programming is **irreversible**. Make sure all settings are correct before programming. ## CRC Retry Configuration Configure automatic retry on CRC errors: ```cpp // Read with automatic retry (3 attempts) uint16_t angle = encoder.GetAngle(3); // Or set default retries in config // AS5047U_CFG::CRC_RETRIES = 3; ``` ## Default Values | Option | Default | Description |--------|---------|-------------| `DEFAULT_FRAME_FORMAT` | `SPI_16` | SPI frame format | `CRC_RETRIES` | `0` | Number of CRC retries | Zero Position | `0` | Zero reference angle | Direction | `true` (CW) | Rotation direction | DAEC | `enabled` | Dynamic angle compensation | Adaptive Filter | `enabled` | DFS adaptive filtering | ABI Resolution | `14-bit` | Incremental output resolution | UVW Pole Pairs | `1` | Commutation pole pairs | ## Recommended Settings ### For High-Speed Motor Control ```cpp encoder.SetDynamicAngleCompensation(true); // Enable DAEC encoder.SetAdaptiveFilter(true); // Enable DFS encoder.SetFilterParameters(2, 3); // Moderate filtering encoder.SetABIResolution(12); // 4096 PPR encoder.ConfigureInterface(true, false, false); // ABI output ``` ### For Low-Noise Applications ```cpp encoder.SetAdaptiveFilter(true); encoder.SetFilterParameters(3, 5); // Stronger filtering encoder.SetHysteresis(AS5047U_REG::SETTINGS3::Hysteresis::LSB_2); ``` ### For Basic Angle Reading ```cpp // Use default settings, just read angle uint16_t angle = encoder.GetAngle(); ``` ## Next Steps - See [Examples](/hf-as5047u-driver/development/docs/examples.html) for configuration examples - Review [API Reference](/hf-as5047u-driver/development/docs/api_reference.html) for all configuration methods --- **Navigation** ‚¨ÖÔ∏è [Platform Integration](/hf-as5047u-driver/development/docs/platform_integration.html) | [Next: API Reference ‚û°Ô∏è](/hf-as5047u-driver/development/docs/api_reference.html) | [Back to Index](/hf-as5047u-driver/development/docs/) ",
    "url": "/hf-as5047u-driver/development/docs/configuration.html",
    
    "relUrl": "/docs/configuration.html"
  },"2": {
    "doc": "Examples",
    "title": "Examples",
    "content": "# Examples This guide provides complete, working examples demonstrating various use cases for the AS5047U driver. ## Example 1: Basic Angle Reading This example shows the minimal setup required to read angle values. ```cpp #include \"as5047u.hpp\" #include \"esp32_as5047u_bus.hpp\" // Your SPI implementation void app_main() { // 1. Configure SPI bus Esp32As5047uBus::SPIConfig config; config.miso_pin = GPIO_NUM_2; config.mosi_pin = GPIO_NUM_7; config.sclk_pin = GPIO_NUM_6; config.cs_pin = GPIO_NUM_10; config.frequency = 4000000; config.mode = 1; auto bus = std::make_unique(config); bus->initialize(); // 2. Create encoder instance as5047u::AS5047U encoder(*bus, FrameFormat::SPI_24); // 3. Read angle in a loop while (true) { uint16_t angle = encoder.GetAngle(); float angle_deg = angle * 360.0f / 16384.0f; printf(\"Angle: %u (%.2f¬∞)\\n\", angle, angle_deg); vTaskDelay(pdMS_TO_TICKS(100)); } } ``` ### Explanation 1. **SPI Configuration**: Configure the SPI bus with appropriate pins and settings 2. **Encoder Creation**: Create the encoder instance with SPI bus and frame format 3. **Angle Reading**: Read angle values in a loop and convert to degrees ### Expected Output ``` Angle: 8192 (180.00¬∞) Angle: 8200 (180.18¬∞) Angle: 8208 (180.35¬∞) ``` --- ## Example 2: Velocity Measurement This example demonstrates reading velocity in different units. ```cpp #include \"as5047u.hpp\" void app_main() { // ... SPI setup (same as Example 1) as5047u::AS5047U encoder(*bus, FrameFormat::SPI_24); while (true) { // Read velocity in different units int16_t vel_lsb = encoder.GetVelocity(); float vel_dps = encoder.GetVelocityDegPerSec(); float vel_rpm = encoder.GetVelocityRPM(); printf(\"Velocity: %d LSB, %.2f deg/s, %.2f RPM\\n\", vel_lsb, vel_dps, vel_rpm); vTaskDelay(pdMS_TO_TICKS(100)); } } ``` ### Explanation The driver provides multiple velocity unit conversions: - `GetVelocity()` - Returns signed 14-bit LSB units - `GetVelocityDegPerSec()` - Returns degrees per second - `GetVelocityRPM()` - Returns revolutions per minute --- ## Example 3: Diagnostics and Error Handling This example shows proper error handling and diagnostic reading. ```cpp #include \"as5047u.hpp\" void app_main() { // ... SPI setup as5047u::AS5047U encoder(*bus, FrameFormat::SPI_24); while (true) { // Read angle with retry on CRC errors uint16_t angle = encoder.GetAngle(3); // 3 retries // Read diagnostics uint8_t agc = encoder.GetAGC(); uint16_t mag = encoder.GetMagnitude(); // Check for errors AS5047U_Error errors = encoder.GetStickyErrorFlags(); if (errors != AS5047U_Error::None) { printf(\"Error detected: 0x%04X\\n\", static_cast(errors)); // Check specific errors if (errors & static_cast(AS5047U_Error::AgcWarning)) { printf(\"Warning: AGC at limit - check magnet placement\\n\"); } if (errors & static_cast(AS5047U_Error::CrcError)) { printf(\"Warning: CRC error detected\\n\"); } } printf(\"Angle: %u, AGC: %u, Mag: %u\\n\", angle, agc, mag); vTaskDelay(pdMS_TO_TICKS(100)); } } ``` ### Explanation 1. **CRC Retry**: Pass retry count to `GetAngle()` for automatic retry on CRC errors 2. **Diagnostics**: Read AGC and magnitude for health monitoring 3. **Error Checking**: Check error flags and handle specific error conditions --- ## Example 4: ABI Incremental Output Configuration This example configures the AS5047U to output incremental encoder signals (A, B, I). ```cpp #include \"as5047u.hpp\" void app_main() { // ... SPI setup as5047u::AS5047U encoder(*bus, FrameFormat::SPI_24); // Configure ABI output encoder.SetABIResolution(12); // 12-bit = 4096 PPR encoder.SetIndexPulseLength(1); // Index pulse length encoder.ConfigureInterface(true, false, false); // Enable ABI, disable UVW and PWM printf(\"ABI output configured: 12-bit (4096 PPR)\\n\"); printf(\"Connect A, B, I pins to your motor controller\\n\"); // Continue reading angle via SPI while (true) { uint16_t angle = encoder.GetAngle(); printf(\"Angle: %u\\n\", angle); vTaskDelay(pdMS_TO_TICKS(100)); } } ``` ### Explanation 1. **Resolution**: Set ABI resolution (10-14 bits) 2. **Index Pulse**: Configure index pulse width 3. **Interface**: Enable ABI output via `ConfigureInterface()` --- ## Example 5: UVW Commutation Output Configuration This example configures the AS5047U to output 3-phase commutation signals (U, V, W). ```cpp #include \"as5047u.hpp\" void app_main() { // ... SPI setup as5047u::AS5047U encoder(*bus, FrameFormat::SPI_24); // Configure UVW output encoder.SetUVWPolePairs(5); // 5 pole pairs encoder.ConfigureInterface(false, true, false); // Disable ABI, enable UVW, disable PWM printf(\"UVW output configured: 5 pole pairs\\n\"); printf(\"Connect U, V, W pins to your motor controller\\n\"); // Continue reading angle via SPI while (true) { uint16_t angle = encoder.GetAngle(); printf(\"Angle: %u\\n\", angle); vTaskDelay(pdMS_TO_TICKS(100)); } } ``` ### Explanation 1. **Pole Pairs**: Set number of pole pairs (1-7) for your motor 2. **Interface**: Enable UVW output via `ConfigureInterface()` --- ## Example 6: Advanced Features (DAEC and Filtering) This example demonstrates enabling DAEC and adaptive filtering for high-performance applications. ```cpp #include \"as5047u.hpp\" void app_main() { // ... SPI setup as5047u::AS5047U encoder(*bus, FrameFormat::SPI_24); // Enable advanced features encoder.SetDynamicAngleCompensation(true); // Enable DAEC encoder.SetAdaptiveFilter(true); // Enable DFS encoder.SetFilterParameters(2, 3); // Set filter parameters printf(\"DAEC and adaptive filter enabled\\n\"); while (true) { // Read compensated angle (with DAEC) uint16_t angle = encoder.GetAngle(); // Read raw angle (without DAEC) for comparison uint16_t raw_angle = encoder.GetRawAngle(); printf(\"Compensated: %u, Raw: %u\\n\", angle, raw_angle); vTaskDelay(pdMS_TO_TICKS(100)); } } ``` ### Explanation 1. **DAEC**: Dynamic Angle Error Compensation for low-latency angle correction 2. **Adaptive Filter**: Dynamic Filter System for noise reduction 3. **Filter Parameters**: Set K_min and K_max for filter strength --- ## Example 7: Zero Position Calibration This example shows how to set a zero reference position. ```cpp #include \"as5047u.hpp\" void app_main() { // ... SPI setup as5047u::AS5047U encoder(*bus, FrameFormat::SPI_24); // Wait for sensor to stabilize vTaskDelay(pdMS_TO_TICKS(100)); // Read current angle uint16_t current_angle = encoder.GetAngle(); // Set it as zero reference if (encoder.SetZeroPosition(current_angle)) { printf(\"Zero position set to: %u\\n\", current_angle); } else { printf(\"Failed to set zero position\\n\"); } // Now angle readings will be relative to this position while (true) { uint16_t angle = encoder.GetAngle(); printf(\"Angle: %u\\n\", angle); vTaskDelay(pdMS_TO_TICKS(100)); } } ``` ### Explanation 1. **Stabilize**: Wait for sensor to stabilize after power-on 2. **Read Current**: Read the current angle position 3. **Set Zero**: Set the current position as zero reference --- ## Example 8: Full Feature Configuration This example demonstrates configuring all features together. ```cpp #include \"as5047u.hpp\" void app_main() { // ... SPI setup as5047u::AS5047U encoder(*bus, FrameFormat::SPI_24); // Configure all features encoder.SetZeroPosition(0); encoder.SetDirection(true); // Clockwise = positive encoder.SetDynamicAngleCompensation(true); encoder.SetAdaptiveFilter(true); encoder.SetFilterParameters(2, 3); encoder.SetABIResolution(12); encoder.SetUVWPolePairs(5); encoder.ConfigureInterface(true, true, false); // ABI + UVW printf(\"Full configuration applied\\n\"); // Dump status for verification encoder.DumpStatus(); // Main loop while (true) { uint16_t angle = encoder.GetAngle(); float vel_dps = encoder.GetVelocityDegPerSec(); uint8_t agc = encoder.GetAGC(); printf(\"Angle: %u, Vel: %.2f deg/s, AGC: %u\\n\", angle, vel_dps, agc); vTaskDelay(pdMS_TO_TICKS(100)); } } ``` ### Explanation This example shows a complete configuration with all major features enabled. --- ## Running the Examples ### ESP32 ```bash cd examples/esp32 idf.py build flash monitor ``` ### Other Platforms For other platforms, implement the SPI interface and compile with C++20 support: ```bash g++ -std=c++20 -I inc/ your_code.cpp src/AS5047U.cpp ``` ## Next Steps - Review the [API Reference](/hf-as5047u-driver/development/docs/api_reference.html) for method details - Check [Troubleshooting](/hf-as5047u-driver/development/docs/troubleshooting.html) if you encounter issues - Explore the [examples directory](../examples/) for more examples --- **Navigation** ‚¨ÖÔ∏è [API Reference](/hf-as5047u-driver/development/docs/api_reference.html) | [Next: Troubleshooting ‚û°Ô∏è](/hf-as5047u-driver/development/docs/troubleshooting.html) | [Back to Index](/hf-as5047u-driver/development/docs/) ",
    "url": "/hf-as5047u-driver/development/docs/examples.html",
    
    "relUrl": "/docs/examples.html"
  },"3": {
    "doc": "Hardware Setup",
    "title": "Hardware Setup",
    "content": "# Hardware Setup This guide covers the physical connections and hardware requirements for the AS5047U magnetic encoder chip. ## Pin Connections ### Basic SPI Connections ``` MCU AS5047U ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ VDD GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ GND SCK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CLK MOSI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ MISO (note: AS5047U uses MISO for both directions) MISO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ MOSI CS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CSn ``` ### Pin Descriptions | Pin | Name | Description | Required |-----|------|-------------|----------| VDD | Power | 3.3V power supply (2.7V - 3.6V) | Yes | GND | Ground | Ground reference | Yes | CLK | Clock | SPI clock line | Yes | MISO | Master In | SPI data input (MCU receives) | Yes | MOSI | Master Out | SPI data output (MCU transmits) | Yes | CSn | Chip Select | SPI chip select (active low) | Yes | PROG | Program | OTP programming enable (optional) | No | **Note**: The AS5047U uses a unique SPI configuration where MISO and MOSI are swapped compared to standard SPI. The MCU's MOSI connects to the AS5047U's MISO pin, and the MCU's MISO connects to the AS5047U's MOSI pin. ## Power Requirements - **Supply Voltage**: 2.7V - 3.6V (3.3V typical) - **Current Consumption**: 6.5 mA typical, 10 mA maximum - **Power Supply**: Clean 3.3V supply with decoupling capacitor (100nF ceramic + 10¬µF tantalum recommended) ## SPI Configuration - **Mode**: SPI Mode 1 (CPOL=0, CPHA=1) or Mode 3 (CPOL=1, CPHA=1) - **Speed**: Up to 10 MHz (4 MHz recommended for reliability) - **Bit Order**: MSB first - **CS Polarity**: Active low (CSn) - **Frame Formats**: 16-bit, 24-bit (with CRC), or 32-bit (with CRC) ## Magnetic Setup The AS5047U requires a diametrically magnetized magnet positioned above the sensor: - **Magnet Type**: Diametrically magnetized (2-pole) magnet - **Magnet Diameter**: 6-12 mm recommended - **Air Gap**: 0.5 - 3.0 mm (1.0 mm typical) - **Alignment**: Centered above the sensor die - **Field Strength**: 30-100 mT at the sensor surface ## Physical Layout Recommendations - Keep SPI traces short (< 10cm recommended) - Use ground plane for noise reduction - Place decoupling capacitors (100nF ceramic + 10¬µF tantalum) close to VDD pin - Route clock and data lines away from noise sources - Keep magnet away from ferromagnetic materials - Avoid stray magnetic fields from motors or other sources ## Example Wiring Diagram ``` AS5047U ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ VDD ‚îÇ GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ GND ‚îÇ SCK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ CLK ‚îÇ MOSI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ MISO ‚îÇ MISO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ MOSI ‚îÇ CS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ CSn ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ (air gap 0.5-3mm) ‚ñº ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Magnet‚îÇ ‚îÇ (6-12mm)‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ``` ## Incremental Output Pins (ABI) If using ABI incremental outputs: | Pin | Name | Description |-----|------|-------------| A | A | Incremental encoder A output | B | B | Incremental encoder B output | I | I | Index pulse output | ## Commutation Output Pins (UVW) If using UVW commutation outputs: | Pin | Name | Description |-----|------|-------------| U | U | Commutation U output | V | V | Commutation V output | W | W | Commutation W output | ## PWM Output If using PWM output: | Pin | Name | Description |-----|------|-------------| PWM | PWM | PWM-encoded angle output (on W or I pin depending on configuration) | ## Next Steps - Verify connections with a multimeter - Proceed to [Quick Start](/hf-as5047u-driver/development/docs/quickstart.html) to test the connection - Review [Platform Integration](/hf-as5047u-driver/development/docs/platform_integration.html) for software setup --- **Navigation** ‚¨ÖÔ∏è [Quick Start](/hf-as5047u-driver/development/docs/quickstart.html) | [Next: Platform Integration ‚û°Ô∏è](/hf-as5047u-driver/development/docs/platform_integration.html) | [Back to Index](/hf-as5047u-driver/development/docs/) ",
    "url": "/hf-as5047u-driver/development/docs/hardware_setup.html",
    
    "relUrl": "/docs/hardware_setup.html"
  },"4": {
    "doc": "HF-AS5047U Documentation",
    "title": "HF-AS5047U Documentation",
    "content": "# HF-AS5047U Documentation Welcome! This directory contains step-by-step guides for installing, building, and using the **HF-AS5047U** library. ## üìö Documentation Structure ### **Getting Started** 1. **[üõ†Ô∏è Installation](/hf-as5047u-driver/development/docs/installation.html)** ‚Äì Prerequisites and how to obtain the source 2. **[‚ö° Quick Start](/hf-as5047u-driver/development/docs/quickstart.html)** ‚Äì Minimal working example to get you running 3. **[üîå Hardware Setup](/hf-as5047u-driver/development/docs/hardware_setup.html)** ‚Äì Wiring diagrams and pin connections ### **Integration** 4. **[üîß Platform Integration](/hf-as5047u-driver/development/docs/platform_integration.html)** ‚Äì Implement the CRTP SPI interface for your platform 5. **[‚öôÔ∏è Configuration](/hf-as5047u-driver/development/docs/configuration.html)** ‚Äì Configuration options and settings ### **Reference** 6. **[üìñ API Reference](/hf-as5047u-driver/development/docs/api_reference.html)** ‚Äì Complete API documentation 7. **[üí° Examples](/hf-as5047u-driver/development/docs/examples.html)** ‚Äì Detailed example walkthroughs ### **Troubleshooting** 8. **[üêõ Troubleshooting](/hf-as5047u-driver/development/docs/troubleshooting.html)** ‚Äì Common issues and solutions --- ## üöÄ Quick Start Path **New to AS5047U?** Follow this recommended path: 1. Start with **[Installation](/hf-as5047u-driver/development/docs/installation.html)** to prepare your environment 2. Follow **[Hardware Setup](/hf-as5047u-driver/development/docs/hardware_setup.html)** to wire your hardware 3. Read **[Quick Start](/hf-as5047u-driver/development/docs/quickstart.html)** for a minimal working example 4. Check **[Platform Integration](/hf-as5047u-driver/development/docs/platform_integration.html)** to implement the SPI interface 5. Explore **[Examples](/hf-as5047u-driver/development/docs/examples.html)** for more advanced usage --- ## üí° Need Help? - **üêõ Found a bug?** Check the [Troubleshooting](/hf-as5047u-driver/development/docs/troubleshooting.html) guide - **‚ùì Have questions?** Review the [API Reference](/hf-as5047u-driver/development/docs/api_reference.html) - **üìù Want to contribute?** See the contributing guidelines in the main README --- **Navigation** ‚û°Ô∏è [Installation](/hf-as5047u-driver/development/docs/installation.html) ",
    "url": "/hf-as5047u-driver/development/docs/",
    
    "relUrl": "/docs/"
  },"5": {
    "doc": "Installation",
    "title": "Installation",
    "content": "# Installation This guide covers how to obtain and integrate the AS5047U driver library into your project. ## Prerequisites Before installing the driver, ensure you have: - **C++20 Compiler**: GCC 10+, Clang 12+, or MSVC 2019+ - **Build System**: Make, CMake, or ESP-IDF (depending on your platform) - **Platform SDK**: ESP-IDF, STM32 HAL, Arduino, or your platform's SPI driver ## Obtaining the Source ### Option 1: Git Clone ```bash git clone https://github.com/n3b3x/hf-as5047u-driver.git cd hf-as5047u-driver ``` ### Option 2: Copy Files Copy the following files into your project: ``` inc/ ‚îú‚îÄ‚îÄ as5047u.hpp ‚îú‚îÄ‚îÄ as5047u_spi_interface.hpp ‚îú‚îÄ‚îÄ AS5047U_REGISTERS.hpp ‚îú‚îÄ‚îÄ AS5047U_types.hpp ‚îî‚îÄ‚îÄ AS5047U_config.hpp src/ ‚îî‚îÄ‚îÄ AS5047U.cpp ``` ## Integration Methods ### Using CMake Add the driver as a subdirectory in your `CMakeLists.txt`: ```cmake add_subdirectory(external/hf-as5047u-driver) target_link_libraries(your_target PRIVATE hf_as5047u) target_include_directories(your_target PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/external/hf-as5047u-driver/inc ) ``` ### Using ESP-IDF Component The driver can be used as an ESP-IDF component. Add it to your `components` directory: ```cmake # In your main CMakeLists.txt idf_component_register( SRCS \"your_code.cpp\" INCLUDE_DIRS \".\" REQUIRES hf_as5047u ) ``` ### Manual Integration 1. Copy the driver files to your project 2. Add the `inc/` directory to your include path 3. Include the header: ```cpp #include \"as5047u.hpp\" ``` 4. Compile with C++20 support: ```bash g++ -std=c++20 -I inc/ your_code.cpp src/AS5047U.cpp ``` ## Running Unit Tests The library includes unit tests. To run them: ```bash cd tests g++ -std=c++20 -I ../inc ../src/AS5047U.cpp test_as5047u.cpp -o test ./test ``` Expected output: ``` All tests passed. ``` ## Verification To verify the installation: 1. Include the header in a test file: ```cpp #include \"as5047u.hpp\" ``` 2. Compile a simple test: ```bash g++ -std=c++20 -I inc/ -c src/AS5047U.cpp -o test.o ``` 3. If compilation succeeds, the library is properly installed. ## Next Steps - Follow the [Quick Start](/hf-as5047u-driver/development/docs/quickstart.html) guide to create your first application - Review [Hardware Setup](/hf-as5047u-driver/development/docs/hardware_setup.html) for wiring instructions - Check [Platform Integration](/hf-as5047u-driver/development/docs/platform_integration.html) to implement the SPI interface --- **Navigation** ‚¨ÖÔ∏è [Back to Index](/hf-as5047u-driver/development/docs/) | [Next: Quick Start ‚û°Ô∏è](/hf-as5047u-driver/development/docs/quickstart.html) ",
    "url": "/hf-as5047u-driver/development/docs/installation.html",
    
    "relUrl": "/docs/installation.html"
  },"6": {
    "doc": "Platform Integration Guide",
    "title": "Platform Integration Guide",
    "content": "# Platform Integration Guide This guide explains how to implement the hardware abstraction interface for the AS5047U driver on your platform. ## Understanding CRTP (Curiously Recurring Template Pattern) The AS5047U driver uses **CRTP** (Curiously Recurring Template Pattern) for hardware abstraction. This design choice provides several critical benefits for embedded systems: ### Why CRTP Instead of Virtual Functions? #### 1. **Zero Runtime Overhead** - **Virtual functions**: Require a vtable lookup (indirect call) = ~5-10 CPU cycles overhead per call - **CRTP**: Direct function calls = 0 overhead, compiler can inline - **Impact**: In time-critical embedded code reading angles at high rates, this matters significantly #### 2. **Compile-Time Polymorphism** - **Virtual functions**: Runtime dispatch - the compiler cannot optimize across the abstraction boundary - **CRTP**: Compile-time dispatch - full optimization, dead code elimination, constant propagation - **Impact**: Smaller code size, faster execution #### 3. **Memory Efficiency** - **Virtual functions**: Each object needs a vtable pointer (4-8 bytes) - **CRTP**: No vtable pointer needed - **Impact**: Critical in memory-constrained systems (many MCUs have class SpiInterface { public: void transfer(const uint8_t* tx, uint8_t* rx, std::size_t len) { // Cast 'this' to Derived* and call the derived implementation static_cast(this)->transfer(tx, rx, len); } }; // Your implementation class MySPI : public as5047u::SpiInterface { public: // This method is called directly (no virtual overhead) void transfer(const uint8_t* tx, uint8_t* rx, std::size_t len) { // Your platform-specific SPI code } }; ``` The key insight: `static_cast(this)` allows the base class to call methods on the derived class **at compile time**, not runtime. ### Performance Comparison | Aspect | Virtual Functions | CRTP |--------|------------------|------| Function call overhead | ~5-10 cycles | 0 cycles (inlined) | Code size | Larger (vtables) | Smaller (optimized) | Memory per object | +4-8 bytes (vptr) | 0 bytes | Compile-time checks | No | Yes | Optimization | Limited | Full | ## Interface Definition The AS5047U driver requires you to implement the following interface: ```cpp template class SpiInterface { public: // Required method void transfer(const uint8_t* tx, uint8_t* rx, std::size_t len); }; ``` **Key Requirements:** - `tx`: Pointer to data to transmit (can be `nullptr` to send zeros) - `rx`: Pointer to buffer for received data (can be `nullptr` to ignore received data) - `len`: Number of bytes to transfer - **CS Management**: Your implementation must assert chip select before transfer and deassert after - **SPI Mode**: AS5047U uses SPI Mode 1 (CPOL=0, CPHA=1) or Mode 3 (CPOL=1, CPHA=1) - **Bit Order**: MSB first ## Implementation Steps ### Step 1: Create Your Implementation Class ```cpp #include \"as5047u_spi_interface.hpp\" class MyPlatformSPI : public as5047u::SpiInterface { private: // Your platform-specific members spi_device_handle_t spi_device_; // Example for ESP32 public: // Constructor MyPlatformSPI(spi_device_handle_t device) : spi_device_(device) {} // Implement required method void transfer(const uint8_t* tx, uint8_t* rx, std::size_t len) { // Assert CS // Perform SPI transfer // Deassert CS } }; ``` ### Step 2: Platform-Specific Examples #### ESP32 (ESP-IDF) ```cpp #include \"driver/spi_master.h\" #include \"as5047u_spi_interface.hpp\" class Esp32SPIBus : public as5047u::SpiInterface { private: spi_device_handle_t spi_device_; public: Esp32SPIBus(spi_device_handle_t device) : spi_device_(device) {} void transfer(const uint8_t* tx, uint8_t* rx, std::size_t len) { spi_transaction_t trans = {}; trans.length = len * 8; // Length in bits trans.tx_buffer = tx; trans.rx_buffer = rx; esp_err_t ret = spi_device_transmit(spi_device_, &trans); if (ret != ESP_OK) { // Handle error } } }; ``` **Full ESP32 Example:** ```cpp // From examples/esp32/main/esp32_as5047u_bus.hpp class Esp32As5047uBus : public as5047u::SpiInterface { public: struct SPIConfig { spi_host_device_t host = SPI2_HOST; gpio_num_t miso_pin = GPIO_NUM_2; gpio_num_t mosi_pin = GPIO_NUM_7; gpio_num_t sclk_pin = GPIO_NUM_6; gpio_num_t cs_pin = GPIO_NUM_10; uint32_t frequency = 4000000; uint8_t mode = 1; // SPI Mode 1 }; explicit Esp32As5047uBus(const SPIConfig& config); ~Esp32As5047uBus(); bool initialize(); void transfer(const uint8_t* tx, uint8_t* rx, std::size_t len); private: SPIConfig config_; spi_device_handle_t spi_device_; bool initialized_; }; ``` #### STM32 (HAL) ```cpp #include \"stm32f4xx_hal.h\" #include \"as5047u_spi_interface.hpp\" extern SPI_HandleTypeDef hspi1; class STM32SPIBus : public as5047u::SpiInterface { private: GPIO_TypeDef* cs_port_; uint16_t cs_pin_; public: STM32SPIBus(GPIO_TypeDef* cs_port, uint16_t cs_pin) : cs_port_(cs_port), cs_pin_(cs_pin) {} void transfer(const uint8_t* tx, uint8_t* rx, std::size_t len) { // Assert CS HAL_GPIO_WritePin(cs_port_, cs_pin_, GPIO_PIN_RESET); // Perform transfer HAL_StatusTypeDef status = HAL_SPI_TransmitReceive(&hspi1, (uint8_t*)tx, (uint8_t*)rx, len, HAL_MAX_DELAY); // Deassert CS HAL_GPIO_WritePin(cs_port_, cs_pin_, GPIO_PIN_SET); if (status != HAL_OK) { // Handle error } } }; ``` #### Arduino ```cpp #include #include \"as5047u_spi_interface.hpp\" class ArduinoSPIBus : public as5047u::SpiInterface { private: uint8_t cs_pin_; public: ArduinoSPIBus(uint8_t cs_pin) : cs_pin_(cs_pin) { pinMode(cs_pin_, OUTPUT); digitalWrite(cs_pin_, HIGH); } void transfer(const uint8_t* tx, uint8_t* rx, std::size_t len) { // Begin transaction with AS5047U settings SPI.beginTransaction(SPISettings(4000000, MSBFIRST, SPI_MODE1)); // Assert CS digitalWrite(cs_pin_, LOW); // Transfer data for (size_t i = 0; i { public: virtual void transfer(...) override { // ‚ùå Virtual keyword not needed // ... } }; ``` ### ‚úÖ Correct CRTP Implementation ```cpp // CORRECT - no virtual keyword class MyBus : public as5047u::SpiInterface { public: void transfer(...) { // ‚úÖ Direct implementation // ... } }; ``` ### ‚ùå Don't Forget the Template Parameter ```cpp // WRONG - missing template parameter class MyBus : public as5047u::SpiInterface { // ‚ùå Compiler error // ... }; ``` ### ‚úÖ Correct Template Parameter ```cpp // CORRECT - pass your class as template parameter class MyBus : public as5047u::SpiInterface { // ‚úÖ // ... }; ``` ### ‚ö†Ô∏è Important: AS5047U SPI Pin Mapping The AS5047U uses a **unique SPI pin mapping**: - MCU MOSI ‚Üí AS5047U MISO (data from MCU to sensor) - MCU MISO ‚Üí AS5047U MOSI (data from sensor to MCU) This is opposite to standard SPI naming. Make sure your wiring matches this! ## Testing Your Implementation After implementing the interface, test it: ```cpp MyPlatformSPI spi(/* your config */); as5047u::AS5047U encoder(spi, FrameFormat::SPI_24); // Test basic operations uint16_t angle = encoder.GetAngle(); uint8_t agc = encoder.GetAGC(); ``` ## Next Steps - See [Configuration](/hf-as5047u-driver/development/docs/configuration.html) for driver configuration options - Check [Examples](/hf-as5047u-driver/development/docs/examples.html) for complete usage examples - Review [API Reference](/hf-as5047u-driver/development/docs/api_reference.html) for all available methods --- **Navigation** ‚¨ÖÔ∏è [Hardware Setup](/hf-as5047u-driver/development/docs/hardware_setup.html) | [Next: Configuration ‚û°Ô∏è](/hf-as5047u-driver/development/docs/configuration.html) ",
    "url": "/hf-as5047u-driver/development/docs/platform_integration.html",
    
    "relUrl": "/docs/platform_integration.html"
  },"7": {
    "doc": "Quick Start",
    "title": "Quick Start",
    "content": "# Quick Start This guide will get you up and running with the AS5047U driver in just a few steps. ## Prerequisites - [Driver installed](/hf-as5047u-driver/development/docs/installation.html) - [Hardware wired](/hf-as5047u-driver/development/docs/hardware_setup.html) - [SPI interface implemented](/hf-as5047u-driver/development/docs/platform_integration.html) ## Minimal Example Here's a complete working example: ```cpp #include \"as5047u.hpp\" // 1. Implement the SPI interface class MySpi : public as5047u::SpiInterface { public: void transfer(const uint8_t* tx, uint8_t* rx, size_t len) { // Your SPI transfer implementation // Assert CS, transfer data, deassert CS } }; // 2. Create instances MySpi spi; as5047u::AS5047U encoder(spi, FrameFormat::SPI_24); // 24-bit frames with CRC // 3. Read angle uint16_t angle = encoder.GetAngle(); // compensated angle (0-16383) float angle_deg = angle * 360.0f / 16384.0f; // convert to degrees // 4. Read velocity int16_t vel = encoder.GetVelocity(); // velocity in LSB float vel_dps = encoder.GetVelocityDegPerSec(); // velocity in deg/s // 5. Diagnostics uint8_t agc = encoder.GetAGC(); // AGC value (0-255) uint16_t mag = encoder.GetMagnitude(); // magnetic magnitude uint16_t errors = encoder.GetErrorFlags(); // error flags ``` ## Step-by-Step Explanation ### Step 1: Include the Header ```cpp #include \"as5047u.hpp\" ``` This includes the main driver class and all necessary types. ### Step 2: Implement the SPI Interface You need to implement the `SpiInterface` for your platform. See [Platform Integration](/hf-as5047u-driver/development/docs/platform_integration.html) for detailed examples. ```cpp class MySpi : public as5047u::SpiInterface { public: void transfer(const uint8_t* tx, uint8_t* rx, size_t len) { // Assert chip select // Perform SPI transfer // Deassert chip select } }; ``` ### Step 3: Create Driver Instance ```cpp MySpi spi; as5047u::AS5047U encoder(spi, FrameFormat::SPI_24); ``` The constructor takes: - A reference to your SPI interface implementation - The SPI frame format: `SPI_16`, `SPI_24` (with CRC), or `SPI_32` (with CRC) ### Step 4: Read Angle ```cpp uint16_t angle = encoder.GetAngle(); // 14-bit angle (0-16383) ``` The angle is returned as a 14-bit value (0-16383), where 0 = 0¬∞ and 16383 = 360¬∞. ### Step 5: Convert to Degrees ```cpp float angle_deg = angle * 360.0f / 16384.0f; ``` ### Step 6: Read Velocity ```cpp int16_t vel = encoder.GetVelocity(); // LSB units float vel_dps = encoder.GetVelocityDegPerSec(); // degrees/second float vel_rpm = encoder.GetVelocityRPM(); // RPM ``` ### Step 7: Check Diagnostics ```cpp uint8_t agc = encoder.GetAGC(); // Automatic Gain Control (0-255) uint16_t mag = encoder.GetMagnitude(); // Magnetic field magnitude uint16_t errors = encoder.GetErrorFlags(); // Error flags ``` ## Complete Example with Error Handling ```cpp #include \"as5047u.hpp\" class MySpi : public as5047u::SpiInterface { // ... SPI implementation }; void app_main() { MySpi spi; as5047u::AS5047U encoder(spi, FrameFormat::SPI_24); while (true) { // Read angle with retry on CRC errors uint16_t angle = encoder.GetAngle(3); // 3 retries // Check for errors AS5047U_Error errors = encoder.GetStickyErrorFlags(); if (errors != AS5047U_Error::None) { printf(\"Error detected: 0x%04X\\n\", static_cast(errors)); } // Read diagnostics uint8_t agc = encoder.GetAGC(); uint16_t mag = encoder.GetMagnitude(); printf(\"Angle: %u (%.2f¬∞), AGC: %u, Mag: %u\\n\", angle, angle * 360.0f / 16384.0f, agc, mag); vTaskDelay(pdMS_TO_TICKS(100)); } } ``` ## Expected Output When running this example, you should see: ``` Angle: 8192 (180.00¬∞), AGC: 128, Mag: 8192 Angle: 8200 (180.18¬∞), AGC: 128, Mag: 8192 Angle: 8208 (180.35¬∞), AGC: 128, Mag: 8192 ``` ## Troubleshooting If you encounter issues: - **Compilation errors**: Check that you've implemented the `transfer()` method in your SPI interface - **CRC errors**: Verify SPI connections and try increasing retry count - **Zero readings**: Check magnet placement and field strength - **See**: [Troubleshooting](/hf-as5047u-driver/development/docs/troubleshooting.html) for common issues ## Next Steps - Explore [Examples](/hf-as5047u-driver/development/docs/examples.html) for more advanced usage - Review the [API Reference](/hf-as5047u-driver/development/docs/api_reference.html) for all available methods - Check [Configuration](/hf-as5047u-driver/development/docs/configuration.html) for customization options --- **Navigation** ‚¨ÖÔ∏è [Installation](/hf-as5047u-driver/development/docs/installation.html) | [Next: Hardware Setup ‚û°Ô∏è](/hf-as5047u-driver/development/docs/hardware_setup.html) | [Back to Index](/hf-as5047u-driver/development/docs/) ",
    "url": "/hf-as5047u-driver/development/docs/quickstart.html",
    
    "relUrl": "/docs/quickstart.html"
  },"8": {
    "doc": "Troubleshooting",
    "title": "Troubleshooting",
    "content": "# Troubleshooting This guide helps you diagnose and resolve common issues when using the AS5047U driver. ## Common Error Messages ### Error: CRC Errors **Symptoms:** - Frequent CRC errors when reading angle - `GetErrorFlags()` returns `CrcError` flag - Unreliable angle readings **Causes:** - SPI signal integrity issues (noise, reflections) - Incorrect SPI mode or timing - Loose connections - SPI speed too high - Power supply noise **Solutions:** 1. **Reduce SPI Speed**: Try lowering SPI frequency (e.g., 1-2 MHz instead of 10 MHz) 2. **Check SPI Mode**: Ensure SPI Mode 1 (CPOL=0, CPHA=1) or Mode 3 (CPOL=1, CPHA=1) 3. **Enable Retries**: Use retry parameter: `encoder.GetAngle(3)` for automatic retry 4. **Verify Connections**: Check all SPI connections are secure 5. **Add Decoupling**: Ensure proper decoupling capacitors (100nF + 10¬µF) near VDD 6. **Check Ground**: Verify good ground connection between MCU and sensor 7. **Use 24-bit Frames**: Switch to `FrameFormat::SPI_24` for CRC protection --- ### Error: Framing Errors **Symptoms:** - `GetErrorFlags()` returns `FramingError` flag - Communication failures **Causes:** - Incorrect SPI frame format - CS timing issues - SPI transaction length mismatch **Solutions:** 1. **Check Frame Format**: Ensure frame format matches sensor configuration 2. **Verify CS Timing**: Check chip select assertion/deassertion timing 3. **Review SPI Implementation**: Ensure `transfer()` method handles CS correctly --- ### Error: AGC Warning **Symptoms:** - `GetErrorFlags()` returns `AgcWarning` flag - AGC value at 0 or 255 - Unreliable readings **Causes:** - Magnet too close or too far from sensor - Weak magnetic field - Stray magnetic fields interfering **Solutions:** 1. **Check Air Gap**: Adjust magnet distance (0.5-3.0 mm recommended, 1.0 mm typical) 2. **Verify Magnet**: Ensure diametrically magnetized magnet (6-12 mm diameter) 3. **Check Field Strength**: Magnetic field should be 30-100 mT at sensor surface 4. **Remove Interference**: Keep magnet away from ferromagnetic materials and motors 5. **Check Alignment**: Ensure magnet is centered above sensor die --- ### Error: Magnitude Half Warning **Symptoms:** - `GetErrorFlags()` returns `MagHalf` flag - Magnetic field magnitude is half of regulated value **Causes:** - Magnet too far from sensor - Weak magnetic field - Incorrect magnet type **Solutions:** 1. **Reduce Air Gap**: Move magnet closer to sensor (within 0.5-3.0 mm range) 2. **Check Magnet Strength**: Verify magnet provides adequate field (30-100 mT) 3. **Verify Magnet Type**: Ensure diametrically magnetized (2-pole) magnet --- ## Hardware Issues ### Device Not Responding **Symptoms:** - No response from sensor - All readings return 0 or invalid values - SPI communication fails **Checklist:** - [ ] Verify power supply voltage is 2.7V - 3.6V (3.3V typical) - [ ] Check all connections are secure (VDD, GND, CLK, MISO, MOSI, CS) - [ ] Verify SPI pin mapping (AS5047U uses reversed MISO/MOSI naming) - [ ] Check CS line is properly controlled (active low) - [ ] Verify SPI mode is correct (Mode 1 or Mode 3) - [ ] Use oscilloscope/logic analyzer to verify bus activity - [ ] Check for short circuits or incorrect wiring --- ### Communication Errors **Symptoms:** - Timeout errors - CRC/checksum errors - Inconsistent readings **Solutions:** - **Check Bus Speed**: Ensure SPI speed is within specifications (up to 10 MHz, 4 MHz recommended) - **Verify Signal Integrity**: Check for noise, reflections, or signal degradation - **Ensure Proper Termination**: Verify proper bus termination - **Check for Loose Connections**: Inspect all connections - **Reduce SPI Speed**: Try lower frequency if issues persist - **Add Pull-ups**: Ensure proper pull-up resistors if needed --- ### Incorrect Angle Readings **Symptoms:** - Angle values don't change when rotating - Angle values jump erratically - Angle values are always zero **Causes:** - Magnet not properly positioned - Incorrect magnet type - Stray magnetic fields - Sensor not initialized **Solutions:** 1. **Check Magnet Placement**: Verify magnet is centered and at correct distance 2. **Verify Magnet Type**: Ensure diametrically magnetized (2-pole) magnet 3. **Check for Interference**: Remove sources of stray magnetic fields 4. **Verify Initialization**: Ensure SPI bus is properly initialized 5. **Check Error Flags**: Read error flags to diagnose specific issues --- ## Software Issues ### Compilation Errors **Error: \"No matching function\"** **Solution:** - Ensure you've implemented the `transfer()` method in your SPI interface - Check method signature matches: `void transfer(const uint8_t* tx, uint8_t* rx, std::size_t len)` - Verify you're inheriting from `as5047u::SpiInterface` **Error: \"Undefined reference\"** **Solution:** - Verify you're linking the driver source file (`AS5047U.cpp`) - Check include paths are correct - Ensure C++20 standard is enabled: `-std=c++20` **Error: \"Template instantiation failed\"** **Solution:** - Verify your SPI interface class is properly templated: `class MySPI : public as5047u::SpiInterface` - Check that all required methods are implemented --- ### Runtime Errors **Initialization Fails** **Checklist:** - [ ] SPI bus interface is properly initialized - [ ] Hardware connections are correct - [ ] SPI configuration matches sensor requirements - [ ] Device is powered and ready - [ ] CS pin is correctly configured **Unexpected Behavior** **Checklist:** - [ ] Verify configuration matches your use case - [ ] Check for timing issues (add delays if needed) - [ ] Review error handling code - [ ] Verify frame format is correct - [ ] Check error flags for diagnostic information --- ## Debugging Tips ### Enable Debug Output Add debug prints to your SPI implementation: ```cpp void transfer(const uint8_t* tx, uint8_t* rx, std::size_t len) { printf(\"SPI Transfer: len=%zu\\n\", len); // ... your SPI code } ``` ### Use DumpStatus() Print comprehensive sensor status: ```cpp encoder.DumpStatus(); ``` This prints angle, velocity, AGC, magnitude, and error flags. ### Check Error Flags Always check error flags after operations: ```cpp uint16_t angle = encoder.GetAngle(); AS5047U_Error errors = encoder.GetStickyErrorFlags(); if (errors != AS5047U_Error::None) { printf(\"Errors: 0x%04X\\n\", static_cast(errors)); } ``` ### Use a Logic Analyzer For bus communication issues, a logic analyzer can help: - Verify correct protocol timing - Check for signal integrity issues - Validate data being sent/received - Debug CS timing issues ### Verify SPI Pin Mapping **Important**: AS5047U uses reversed SPI pin naming: - MCU MOSI ‚Üí AS5047U MISO (data from MCU to sensor) - MCU MISO ‚Üí AS5047U MOSI (data from sensor to MCU) Double-check your wiring matches this! --- ## FAQ ### Q: What SPI frame format should I use? **A:** For most applications, use `FrameFormat::SPI_24` - it provides CRC protection with good throughput. Use `SPI_16` for maximum speed (no CRC), or `SPI_32` for daisy-chain applications. ### Q: How do I know if my magnet is positioned correctly? **A:** Check the AGC value - it should be between 10-245 (not at limits 0 or 255). Also check magnitude - it should be in a reasonable range (typically 5000-15000). Use `DumpStatus()` to see all diagnostics. ### Q: Can I use multiple AS5047U sensors on the same SPI bus? **A:** Yes, use `FrameFormat::SPI_32` with different pad bytes for each sensor. Each sensor needs its own CS line. ### Q: Why are my angle readings noisy? **A:** Enable adaptive filtering: `encoder.SetAdaptiveFilter(true)` and adjust filter parameters. Also check magnet placement and ensure proper decoupling capacitors. ### Q: How do I calibrate the zero position? **A:** Read the current angle when at your desired zero position, then call `encoder.SetZeroPosition(current_angle)`. See [Example 7](/hf-as5047u-driver/development/docs/examples.html#example-7-zero-position-calibration) for details. ### Q: What happens if I program OTP incorrectly? **A:** OTP programming is **irreversible**. If you program incorrect settings, you cannot change them. Always verify settings before programming OTP. --- ## Getting More Help If you're still experiencing issues: 1. Check the [API Reference](/hf-as5047u-driver/development/docs/api_reference.html) for method details 2. Review [Examples](/hf-as5047u-driver/development/docs/examples.html) for working code 3. Search existing issues on GitHub 4. Open a new issue with: - Description of the problem - Steps to reproduce - Hardware setup details (MCU, wiring, magnet type) - Error messages/logs - Output from `DumpStatus()` --- **Navigation** ‚¨ÖÔ∏è [Examples](/hf-as5047u-driver/development/docs/examples.html) | [Back to Index](/hf-as5047u-driver/development/docs/) ",
    "url": "/hf-as5047u-driver/development/docs/troubleshooting.html",
    
    "relUrl": "/docs/troubleshooting.html"
  },"9": {
    "doc": "HF-AS5047U Driver",
    "title": "HF-AS5047U Driver",
    "content": "# HF-AS5047U Driver **Portable C++20 driver for the AS5047U magnetic encoder from ams with SPI interface, CRC protection, DAEC, and DFS‚Ñ¢** [![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0) [![CI Build](https://github.com/n3b3x/hf-as5047u-driver/actions/workflows/esp32-examples-build-ci.yml/badge.svg?branch=main)](https://github.com/n3b3x/hf-as5047u-driver/actions/workflows/esp32-examples-build-ci.yml) ## üìö Table of Contents 1. [Overview](#-overview) 2. [Features](#-features) 3. [Quick Start](#-quick-start) 4. [Installation](#-installation) 5. [API Reference](#-api-reference) 6. [Examples](#-examples) 7. [Documentation](#-documentation) 8. [Contributing](#-contributing) 9. [License](#-license) ## üì¶ Overview > **üìñ [üìöüåê Live Complete Documentation](https://n3b3x.github.io/hf-as5047u-driver/)** - > Interactive guides, examples, and step-by-step tutorials **HF-AS5047U** is a portable C++20 driver for the **AS5047U** magnetic encoder from ams. It delivers fast 14‚Äëbit absolute angle readings over SPI, optional CRC protection and advanced features like Dynamic Angle Error Compensation (DAEC) and an adaptive Dynamic Filter System (DFS‚Ñ¢). The sensor can also output incremental (A/B/I) and 3‚Äëphase commutation (UVW) signals or a PWM encoded angle, making it a drop‚Äëin replacement for optical encoders in high-performance motor control and robotics. The driver uses a CRTP-based `SpiInterface` for hardware abstraction, allowing it to run on any platform (ESP32, STM32, Arduino, etc.) with zero runtime overhead. It implements all major features from the AS5047U datasheet including absolute angle readout with/without DAEC, velocity measurement, AGC and magnetic field diagnostics, ABI/UVW/PWM interface configuration, error/status flag handling, and full OTP programming sequence. ## ‚ú® Features - ‚úÖ **14-bit absolute angle** with optional CRC check - ‚úÖ **DAEC** (Dynamic Angle Error Compensation) for low-latency angle correction - ‚úÖ **DFS‚Ñ¢** (Dynamic Filter System) adaptive noise filtering - ‚úÖ **Stray-field immunity** for robust operation - ‚úÖ **Incremental ABI outputs** up to 4096 PPR - ‚úÖ **UVW commutation** with programmable pole pairs - ‚úÖ **PWM output** option - ‚úÖ **Diagnostics** for AGC, magnitude and error flags - ‚úÖ **OTP memory** for permanent configuration - ‚úÖ **Hardware Agnostic**: SPI interface for platform independence - ‚úÖ **Modern C++**: C++20 with CRTP-based design - ‚úÖ **Zero Overhead**: CRTP-based design for compile-time polymorphism ## üöÄ Quick Start ```cpp #include \"as5047u.hpp\" // 1. Implement the SPI interface (see platform_integration.md) class MySpi : public as5047u::SpiInterface { public: void transfer(const uint8_t* tx, uint8_t* rx, size_t len) { // Your SPI transfer implementation } }; // 2. Create driver instance MySpi spi; as5047u::AS5047U encoder(spi, FrameFormat::SPI_24); // 24-bit frames with CRC // 3. Read angle uint16_t angle = encoder.GetAngle(); // compensated angle uint16_t rawAngle = encoder.GetRawAngle(); // raw angle without DAEC int16_t vel = encoder.GetVelocity(); // velocity in sensor units float vel_dps = encoder.GetVelocityDegPerSec(); // velocity in deg/s // 4. Diagnostics uint8_t agc = encoder.GetAGC(); // automatic gain control uint16_t mag = encoder.GetMagnitude(); // magnetic magnitude uint16_t errors = encoder.GetErrorFlags(); // current error flags ``` For detailed setup, see [Installation](/hf-as5047u-driver/development/docs/installation.html) and [Quick Start Guide](/hf-as5047u-driver/development/docs/quickstart.html). ## üîß Installation 1. **Clone or copy** the driver files into your project 2. **Implement the SPI interface** for your platform (see [Platform Integration](/hf-as5047u-driver/development/docs/platform_integration.html)) 3. **Include the header** in your code: ```cpp #include \"as5047u.hpp\" ``` 4. Compile with a **C++20** or newer compiler For detailed installation instructions, see [docs/installation.md](/hf-as5047u-driver/development/docs/installation.html). ## üìñ API Reference | Method | Description |--------|-------------| `GetAngle()` | Read 14-bit compensated absolute angle | `GetRawAngle()` | Read 14-bit raw absolute angle | `GetVelocity()` | Read signed 14-bit velocity (LSB units) | `GetVelocityDegPerSec()` | Velocity in degrees/sec | `GetVelocityRPM()` | Velocity in revolutions per minute | `GetAGC()` | Read AGC (0‚Äì255) value | `GetMagnitude()` | Read magnetic field magnitude | `GetErrorFlags()` | Read and clear error/status flags | `SetZeroPosition()` | Set new zero offset | `SetDirection()` | Set rotation direction (CW or CCW) | `SetABIResolution()` | Set ABI output resolution (10‚Äì14 bits) | `SetUVWPolePairs()` | Set UVW pole pairs (1‚Äì7) | `ConfigureInterface()` | Enable/disable ABI, UVW, PWM | `SetDynamicAngleCompensation()` | Enable/disable DAEC | `SetAdaptiveFilter()` | Enable/disable adaptive filter (DFS) | `ProgramOTP()` | Program current settings into OTP | For complete API documentation, see [docs/api_reference.md](/hf-as5047u-driver/development/docs/api_reference.html). ## üìä Examples For ESP32 examples, see the [examples/esp32](examples/esp32/) directory. Additional examples for other platforms are available in the [examples](examples/) directory. Detailed example walkthroughs are available in [docs/examples.md](/hf-as5047u-driver/development/docs/examples.html). ## üìö Documentation For complete documentation, see the [docs directory](/hf-as5047u-driver/development/docs/). ## ü§ù Contributing Pull requests and suggestions are welcome! Please follow the existing code style and include tests for new features. ## üìÑ License This project is licensed under the **GNU General Public License v3.0**. See the [LICENSE](/hf-as5047u-driver/development/LICENSE) file for details. ",
    "url": "/hf-as5047u-driver/development/",
    
    "relUrl": "/"
  },"10": {
    "doc": "AS5047U ESP32-C6 Examples",
    "title": "AS5047U ESP32-C6 Examples",
    "content": "# AS5047U ESP32-C6 Examples This directory contains comprehensive examples demonstrating the AS5047U driver on ESP32-C6 platform. ## üéØ Overview The ESP32-C6 examples showcase real-world usage of the AS5047U magnetic encoder with: - **Hardware-specific HAL** implementation for ESP32-C6 - **Multiple example applications** covering different use cases - **Automated build system** with configurable app types - **Comprehensive documentation** for each example - **Production-ready code** with proper error handling ## üîß Hardware Requirements ### ESP32-C6 Development Board - ESP32-C6-DevKitC-1 or compatible - USB-C cable for programming and power ### AS5047U Connections | AS5047U Pin | ESP32-C6 GPIO | Function |-------------|---------------|----------| MISO | GPIO2 | SPI Data In | MOSI | GPIO7 | SPI Data Out | SCLK | GPIO6 | SPI Clock | CS | GPIO10 | Chip Select | VDD | 3.3V | Logic Supply | GND | GND | Ground | **Note:** The default SPI configuration uses mode 1 (CPOL=0, CPHA=1) at 4MHz. ## üöÄ Quick Start ### 1. Prerequisites ```bash # Install ESP-IDF v5.5 curl -fsSL https://raw.githubusercontent.com/espressif/esp-idf/master/tools/install.sh | bash source ~/esp/esp-idf/export.sh # Verify installation idf.py --version ``` ### 2. Setup Repository ```bash # Clone and setup git clone --recursive https://github.com/n3b3x/hf-as5047u-driver.git cd hf-as5047u-driver/examples/esp32 # Initialize build environment ./scripts/setup_repo.sh ``` ### 3. Build and Flash ```bash # Build driver integration test (default) ./scripts/build_app.sh driver_integration_test Release # Flash to ESP32-C6 ./scripts/flash_app.sh driver_integration_test Release # Monitor output idf.py monitor ``` ## üì± Available Examples ### üü¢ Test Suite #### `driver_integration_test` **Comprehensive Driver Integration Test Suite** - Complete driver API validation (30+ tests) - Multiple test sections covering all functionality - Initialization, angle/velocity reading, diagnostics - Frame format testing (16/24/32-bit) - Configuration and error handling - FreeRTOS task-based test execution - GPIO14 progress indicator - Automatic pass/fail tracking - No actual hardware required (driver test only) **Build:** ```bash ./scripts/build_app.sh driver_integration_test Release ``` ### üü° Basic Examples #### `basic_angle_reading` **Basic Angle Reading Example** - Simple angle reading loop - Angle in LSB and degrees - AGC and magnitude diagnostics - Error flag monitoring - Real hardware testing **Build:** ```bash ./scripts/build_app.sh basic_angle_reading Release ``` #### `velocity_reading` **Velocity Reading Example** - Velocity reading in multiple units - Degrees per second, radians per second, RPM - Real hardware testing **Build:** ```bash ./scripts/build_app.sh velocity_reading Release ``` #### `configuration_example` **Configuration Example** - ABI output configuration - UVW commutation setup - PWM output configuration - Zero position and direction setting - Real hardware testing **Build:** ```bash ./scripts/build_app.sh configuration_example Release ``` #### `full_features` **Comprehensive Example** - All sensor features enabled - Angle, velocity, diagnostics - ABI, UVW, PWM configuration - DAEC and filter settings - OTP programming - Real hardware testing **Build:** ```bash ./scripts/build_app.sh full_features Release ``` ## üî® Building Examples ### Using Build Scripts (Recommended) ```bash # List available app types ./scripts/build_app.sh list # Build specific app ./scripts/build_app.sh # Examples: ./scripts/build_app.sh driver_integration_test Release ./scripts/build_app.sh basic_angle_reading Debug ``` ### Using ESP-IDF Directly ```bash # Set app type and build type idf.py build -DAPP_TYPE=driver_integration_test -DBUILD_TYPE=Release # Flash idf.py flash # Monitor idf.py monitor ``` ## üìä Test Framework All test examples use a standardized test framework with: - **Test result tracking** - Automatic pass/fail counting - **Execution timing** - Performance measurement - **FreeRTOS task execution** - Isolated test environments - **GPIO14 progress indicator** - Visual test progression - **Standardized logging** - Consistent output format ### Test Framework Features - `RUN_TEST(test_func)` - Run test inline - `RUN_TEST_IN_TASK(name, func, stack_size, priority)` - Run test in FreeRTOS task - `RUN_TEST_SECTION_IF_ENABLED(enabled, section_name, ...)` - Conditional test sections - `g_test_results` - Global test results tracking ## üîå Hardware Configuration ### SPI Configuration The default SPI configuration can be modified in the example files: ```cpp Esp32As5047uBus::SPIConfig config; config.miso_pin = GPIO_NUM_2; // MISO pin config.mosi_pin = GPIO_NUM_7; // MOSI pin config.sclk_pin = GPIO_NUM_6; // SCLK pin config.cs_pin = GPIO_NUM_10; // CS pin config.frequency = 4000000; // SPI frequency (4MHz) config.mode = 1; // SPI mode (1: CPOL=0, CPHA=1) ``` ### Pin Configuration | Function | Default GPIO | Notes |----------|-------------|-------| SPI MISO | GPIO2 | Can be changed in code | SPI MOSI | GPIO7 | Can be changed in code | SPI SCLK | GPIO6 | Can be changed in code | SPI CS | GPIO10 | Can be changed in code | Test Progress | GPIO14 | Used by test framework | ### Frame Formats The AS5047U supports three SPI frame formats: - **SPI_16** - 16-bit frames (no CRC, high-throughput mode) - **SPI_24** - 24-bit frames (includes 8-bit CRC for reliability) - **Recommended** - **SPI_32** - 32-bit frames (includes 8-bit CRC and 8-bit pad for daisy-chain) ## üìö Documentation For more detailed documentation, see: - [Main Driver README](/hf-as5047u-driver/development/) - [Setup Guide](../../docs/setup.md) - [Usage Guide](../../docs/usage.md) - [Examples Guide](/hf-as5047u-driver/development/docs/examples.html) - [Building Guide](../../docs/building.md) ## üêõ Troubleshooting ### Build Issues **Error: \"APP_TYPE not defined\"** - Use the build scripts: `./scripts/build_app.sh ` - Or set manually: `idf.py build -DAPP_TYPE=driver_integration_test -DBUILD_TYPE=Release` **Error: \"Failed to read valid app types from app_config.yml\"** - Ensure the scripts submodule is initialized: `git submodule update --init --recursive` - Check that `scripts/get_app_info.py` exists ### Runtime Issues **SPI Communication Errors** - Check wiring connections (MISO, MOSI, SCLK, CS, GND, VDD) - Verify SPI mode (default is mode 1: CPOL=0, CPHA=1) - Check SPI frequency (default is 4MHz) - Verify chip select is properly configured **No Angle Data** - Ensure encoder is powered (3.3V) - Check magnetic field is present (magnitude should be > 0) - Verify SPI communication (check error flags) - Ensure proper SPI frame format (24-bit recommended) **CRC Errors** - Use 24-bit or 32-bit frame format (includes CRC) - Check SPI signal integrity - Verify SPI timing and frequency **Initialization Failures** - Check SPI bus initialization - Verify chip select pin configuration - Ensure proper power supply (3.3V) - Check for SPI bus conflicts ## üìù License See the main driver [LICENSE](/hf-as5047u-driver/development/LICENSE) file. ## ü§ù Contributing See the main driver [Contributing Guide](/hf-as5047u-driver/development/docs/). --- **For questions or issues, please open an issue on GitHub.** ",
    "url": "/hf-as5047u-driver/development/examples/esp32/",
    
    "relUrl": "/examples/esp32/"
  }
}
